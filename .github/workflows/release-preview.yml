name: Release Preview

on:
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  preview:
    name: Preview Next Version
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for semantic-release

      - name: Simulate merge to main
        run: |
          # PR checkout is a detached HEAD at the merge ref.
          # semantic-release requires a branch matching 'main' to detect versions.
          git checkout -B main

      - name: Set up uv and Python
        uses: astral-sh/setup-uv@v7
        with:
          version: "0.10.0"
          enable-cache: true

      - name: Compute version and changelog
        id: version
        run: |
          uv tool install python-semantic-release

          # Get next version
          NEXT_VERSION=$(python-semantic-release version --print || echo "No version change")
          echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT

          # Generate changelog: delete the existing file so PSR regenerates
          # from scratch (produces a proper "## Unreleased" section).
          rm -f CHANGELOG.md
          python-semantic-release changelog

          # Extract the Unreleased section (strip the heading itself)
          CHANGELOG=$(sed -n '/^## Unreleased/,/^## v/{/^## Unreleased/d;/^## v/d;p}' CHANGELOG.md)
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="No changes detected."
          fi

          # Write to file for the next step (multi-line safe)
          echo "$CHANGELOG" > /tmp/changelog-preview.md

      - name: Upsert PR comment
        uses: actions/github-script@v7
        env:
          NEXT_VERSION: ${{ steps.version.outputs.next_version }}
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- release-preview-bot -->';
            const nextVersion = process.env.NEXT_VERSION;
            const changelog = fs.readFileSync('/tmp/changelog-preview.md', 'utf8').trim();

            const body = [
              marker,
              '## Release Preview',
              '',
              `**Next Version:** \`${nextVersion}\``,
              '',
              '### Changelog Preview',
              '',
              changelog,
              '',
              '---',
              '',
              '*This version will be automatically released when this PR is merged to main.*',
              '',
              '**Reminder:** Use conventional commits:',
              '- `fix:` → Patch release (2.0.0 → 2.0.1)',
              '- `feat:` → Minor release (2.0.0 → 2.1.0)',
              '- `feat!:` or `BREAKING CHANGE:` → Major release (2.0.0 → 3.0.0)',
            ].join('\n');

            // Look for an existing comment with our marker (paginate to search all)
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body?.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: body,
              });
              console.log(`Updated existing comment ${existing.id}`);
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body,
              });
              console.log('Created new comment');
            }
