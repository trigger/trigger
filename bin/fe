#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
fe - the File Editor. Uses RCS to maintain ACL policy versioning.
"""

__author__ = ('Jathan McCollum, Mark Ellzey Thomas, Michael Shields, '
              'Michael Harding')
__maintainer__ = 'Jathan McCollum'
__email__ = 'jathan.mccollum@teamaol.com'
__copyright__ = 'Copyright 2002-2013, AOL Inc.'
__version__ = '1.2.1'

import sys
import os
#import trigger.acl.fe as fe
from trigger.utils.cli import yesno
from trigger.conf import settings
from simpleparse.error import ParserSyntaxError
from trigger.exceptions import ParseError
import trigger.acl.fe as fe
import re

# end built-in acl parsing
sys.path.append(os.path.dirname(__file__))

def edit(editfile):
    """
    Edits the file and calls normalize(). Loops until it passes or the user
    confirms they want to bypass failed normalization. Returns a file object of
    the diff output.
    """
    accepted = False
    # following line is essentially a no-op
    # do plug in processing here
    # figure out the base file name, so we can do regular
    # expression parsing
    fn = os.path.basename(editfile)
    try:
        #import fe_extensions
        #tests = fe_extensions.tests
        try:
            sys.path.extend(settings.FE_EXT_DIRS)
        except:
            pass
        ctests = settings.FE_TESTS
        tl = []
        tests = []
        for c in ctests:
            if isinstance(c,basestring):
                tl.append(c)
            else:
                assert(len(c)==2)
                if re.match(c[0],fn):
                    tl.extend(c[1])
                else:
                    continue
            # convert the strings to functions
        for s in tl:
            s = s.split('.')
            m = __import__(s[0])
            for n in s[1:]:
                m = getattr(m, n)
            tests.append(m)
    except (AttributeError, NameError):
        tests = (fe.acltest,)
    while not accepted:
        editor = os.environ.get('EDITOR', 'vim')
        if editor.startswith('vi'):
            os.spawnlp(os.P_WAIT, editor, editor, '+set sw=4',
                       '+set softtabstop=4', editfile)
        else:
            os.spawnlp(os.P_WAIT, editor, editor, editfile)
        for test in tests:
            # match means we think we have the right test,
            # output is either 'False' or the transformed
            # input
            # alternately, a syntax error can be thrown up,
            # meaning we got far enough that this is probably
            # the actual error
            try:
                matches, output = test(editfile)
            except (ParserSyntaxError, ParseError) as e:
                print e
                break
            if not matches:
                continue
            # do a 'None' check to allow empty files...
            if output is not None:
                file(editfile, 'w').write(output)
                accepted = True
                break
            # can't parse the output
        if not accepted and not yesno("can't parse, retry?"):
            accepted = True
        # should we allow a write here?

    # should use a list version of popen
    return os.popen('rcsdiff -u -b -q ' + editfile).read()

if len(sys.argv) < 2:
    print >>sys.stderr, 'usage: fe files...'
    sys.exit(2)

for editfile in sys.argv[1:]:

    try:
        stat = os.stat(editfile)
    except OSError:
        stat = None

    if not stat:

        if yesno('%s does not exist; create?' % editfile, False):
            edit(editfile)
            os.spawnlp(os.P_WAIT, 'ci', 'ci', '-u', editfile)

    else:
        
        rv = os.spawnlp(os.P_WAIT, 'co', 'co', '-f', '-l', editfile)
        if rv:
            print >>sys.stderr, "couldn't check out " + editfile
            continue

        diff = edit(editfile)
        if not diff:
            print 'No changes made.'
            os.spawnlp(os.P_WAIT, 'rcs', 'rcs', '-u', editfile)
            # When no changes are made, ci leaves the file writable.
            os.chmod(editfile, stat.st_mode & 0555)
            continue

        print ''
        print '"%s"' % os.path.basename(editfile)
        print 'BEGINNING OF CHANGES========================'
        print diff,
        print 'END OF CHANGES=============================='
        print ''
        print ''

        if not yesno('Do you want to save changes?'):
            print 'Restoring original file'
            os.spawnlp(os.P_WAIT, 'co', 'co', '-f', '-u', editfile)
            continue

        # Try to auto-detect log message from comments.
        log = ''
        pats = (re.compile(r'^\+.*!+(.*)'), re.compile(r'^\+.*/\*(.*)\*/'))
        for line in diff.split('\n'):
            for pat in pats:
                m = pat.match(line)
                if m:
                    msg = m.group(1).strip()
                    if msg:
                        log += m.group(1).strip() + '\n'
                    break
        if log:
            print 'Autodetected log message:'
            print log
            print ''
            if not yesno('Use this?'):
                log = ''

        if log:
            os.spawnlp(os.P_WAIT, 'ci', 'ci', '-u', '-m' + log, editfile)
        else:
            os.spawnlp(os.P_WAIT, 'ci', 'ci', '-u', editfile)
